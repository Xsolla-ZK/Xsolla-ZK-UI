name: Build & Publish Packages

on:
  push:
    branches:
      - main
    paths:
      - 'packages/**'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version type (major, minor, patch)'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      packages:
        description: 'Comma-separated list of packages to publish (without `packages/` prefix). If left empty ‚Äî will be found all changed packages.'
        required: false
        type: string
      sync_versions:
        description: 'Synchronize all packages to the same version'
        required: false
        default: false
        type: boolean

env:
  REGISTRY_URL: 'https://registry.npmjs.org'
  # If need to use GitHub Packages instead of npmjs.org, uncomment the line below
  # REGISTRY_URL: 'https://npm.pkg.github.com'

jobs:
  prepare:
    name: ‚è≥ Prepare list of packages
    runs-on: ubuntu-latest
    outputs:
      matrix-packages: ${{ steps.set-matrix.outputs['matrix-packages'] }}
      sync-version: ${{ steps.calculate-sync-version.outputs['sync-version'] }}
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîç Define packages to publish
        id: set-matrix
        run: |
          # Packages to exclude from publishing
          EXCLUDED_PACKAGES=("docs" "vue" "app")

          is_excluded() {
            local pkg_name="$1"
            for excluded_pkg in "${EXCLUDED_PACKAGES[@]}"; do
              if [ "$pkg_name" == "$excluded_pkg" ]; then
                return 0
              fi
            done
            return 1
          }

          if [ -n "${{ github.event.inputs.packages }}" ]; then
            echo "üì¶ Manual packages specified: ${{ github.event.inputs.packages }}"
            IFS=',' read -ra ARR <<< "${{ github.event.inputs.packages }}"
            MATRIX_JSON="["
            for pkg in "${ARR[@]}"; do
              trim="$(echo "$pkg" | xargs)"
              pkg_path="packages/${trim}"

              if is_excluded "$trim"; then
                echo "üö´ Excluding package: $pkg_path (not for publishing)"
              else
                echo "‚úÖ Including package: $pkg_path"
                MATRIX_JSON+="\"${pkg_path}\","
              fi
            done
            MATRIX_JSON="${MATRIX_JSON%,}]"

          elif [ "${{ github.event.inputs.sync_versions }}" == "true" ]; then
            echo "üîÑ Sync versions enabled - including all publishable packages"
            MATRIX_JSON="["
            for pkg_dir in packages/*/; do
              if [ -d "$pkg_dir" ]; then
                pkg_name=$(basename "$pkg_dir")

                if is_excluded "$pkg_name"; then
                  echo "üö´ Excluding package: $pkg_dir (not for publishing)"
                else
                  echo "‚úÖ Including package: $pkg_dir"
                  # Remove trailing slash
                  pkg_clean="${pkg_dir%/}"
                  MATRIX_JSON+="\"${pkg_clean}\","
                fi
              fi
            done
            MATRIX_JSON="${MATRIX_JSON%,}]"

          else
            echo "üîç Checking for changed packages since ${{ github.event.before }}"
            CHANGED_PKGS=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} \
                        | grep '^packages/' | cut -d'/' -f2 | sort -u)
            if [ -z "$CHANGED_PKGS" ]; then
              echo "No changes in packages/, nothing to publish."
              MATRIX_JSON="[]"
            else
              echo "Found changed packages, filtering for publishable ones:"
              MATRIX_JSON="["
              for pkg in $CHANGED_PKGS; do
                pkg_path="packages/${pkg}"

                if is_excluded "$pkg"; then
                  echo "üö´ Excluding package: $pkg_path (not for publishing)"
                else
                  echo "‚úÖ Including package: $pkg_path"
                  MATRIX_JSON+="\"${pkg_path}\","
                fi
              done
              MATRIX_JSON="${MATRIX_JSON%,}]"
            fi
          fi

          echo ">>> Final matrix-packages: $MATRIX_JSON"
          echo "matrix-packages=$(jq -cr '@json' <<< "$MATRIX_JSON")" >> $GITHUB_OUTPUT

      - name: üî¢ Calculate synchronized version
        id: calculate-sync-version
        if: github.event.inputs.sync_versions == 'true'
        run: |
          echo "üîÑ Calculating synchronized version based on root package.json..."
          echo "üìù Note: packages docs, vue, app are excluded from publishing"

          # Get version from root package.json
          ROOT_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "0.0.0")
          echo "Root package.json version: $ROOT_VERSION"

          # Calculate new version based on bump type
          VERSION_TYPE="${{ github.event.inputs.version || 'patch' }}"
          echo "Version bump type: $VERSION_TYPE"

          IFS='.' read -ra VERSION_PARTS <<< "$ROOT_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}

          case "$VERSION_TYPE" in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac

          SYNC_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "New synchronized version: $SYNC_VERSION"

          # Update root package.json version
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            pkg.version = '$SYNC_VERSION';
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
          "

          echo "Updated root package.json to version: $SYNC_VERSION"
          echo "sync-version=$SYNC_VERSION" >> $GITHUB_OUTPUT

  debug-matrix:
    name: üêõ Debug matrix-packages
    needs: prepare
    runs-on: ubuntu-latest
    steps:
      - name: Show raw string and length
        run: |
          echo "RAW from prepare: ${{ needs.prepare.outputs['matrix-packages'] }}"
          echo "Not Empty: ${{ fromJson(needs.prepare.outputs['matrix-packages'])[0] != null }}"
          echo "First Element: ${{ fromJson(needs.prepare.outputs['matrix-packages'])[0] }}"

  build:
    name: üî® Build all packages
    runs-on: ubuntu-latest
    needs: prepare
    if: ${{ fromJson(needs.prepare.outputs['matrix-packages']) && fromJson(needs.prepare.outputs['matrix-packages'])[0] != null }}
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ‚öôÔ∏è Setup Node.js & PNPM
        uses: pnpm/action-setup@v4
        with:
          version: '10.3.0'
      - name: üîß Setup Node.js (for npmrc)
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: üì¶ Install dependencies
        run: pnpm install --frozen-lockfile

      - name: üèó Build all packages
        run: pnpm build

      - name: üìù Lint packages
        run: pnpm lint:react

  publish:
    name: üöÄ Publish packages
    needs: [prepare, build]
    runs-on: ubuntu-latest
    if: ${{ fromJson(needs.prepare.outputs['matrix-packages']) && fromJson(needs.prepare.outputs['matrix-packages'])[0] != null }}
    permissions:
      contents: write
      packages: write
    strategy:
      fail-fast: true
      max-parallel: 1
      matrix:
        package-folder: ${{ fromJson(needs.prepare.outputs['matrix-packages']) }}
    outputs:
      published-packages: ${{ steps.published-info.outputs.packages }}

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîç Check if previous packages failed
        run: |
          echo "Checking status of parallel jobs..."
          # This step will help us track if we should continue
          echo "Current package: ${{ matrix.package-folder }}"
          echo "All jobs are being processed sequentially due to max-parallel: 1"

      - name: ‚öôÔ∏è Setup Node.js & PNPM
        uses: pnpm/action-setup@v4
        with:
          version: '10.3.0'
      - name: üîß Setup Node.js (for npmrc)
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          always-auth: true

      - name: üõ°Ô∏è Setup npm Auth
        run: |
          echo "Setting up NPM authentication for ${{ env.REGISTRY_URL }}"

          # Setup .npmrc with registry and auth token
          echo "${{ env.REGISTRY_URL }}/:_authToken=${{ secrets.NPM_TOKEN }}" | sed 's|https://|//|' > ~/.npmrc
          echo "registry=${{ env.REGISTRY_URL }}/" >> ~/.npmrc

          # Verify configuration
          echo "NPM configuration:"
          cat ~/.npmrc | sed 's/_authToken=.*/_authToken=***HIDDEN***/'

          # Test authentication
          echo "Testing NPM authentication:"
          npm whoami || echo "Warning: npm whoami failed, but this might be normal for org tokens"

      - name: üì¶ Install dependencies (only root)
        run: pnpm install --frozen-lockfile

      - name: üßê Check changes in package
        id: check-changes
        working-directory: ${{ matrix['package-folder'] }}
        run: |
          # Take name and version from specified package
          PACKAGE_NAME=$(node -p "require('${PWD}/package.json').name")
          CURRENT_VERSION=$(node -p "require('${PWD}/package.json').version")
          PACKAGE_SHORT_NAME=${PWD##*/}

          # When sync_versions is enabled OR packages are manually specified, always process
          if [ "${{ github.event.inputs.sync_versions }}" == "true" ] || [ -n "${{ github.event.inputs.packages }}" ]; then
            echo "üîÑ Manual trigger or sync versions - processing package: $PACKAGE_NAME"
            echo "skip=false" >> $GITHUB_OUTPUT
          # For workflow_dispatch without sync_versions and packages, process all
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "üì¶ Manual trigger - processing package: $PACKAGE_NAME"
            echo "skip=false" >> $GITHUB_OUTPUT
          # For push events, check if there are changes in this folder
          elif git diff --quiet HEAD~1 HEAD -- . 2>/dev/null; then
            echo "‚è≠Ô∏è No changes in package: $PACKAGE_NAME - skipping"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "üìù Changes detected in package: $PACKAGE_NAME - processing"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

          echo "package_name=${PACKAGE_NAME}" >> $GITHUB_OUTPUT
          echo "package_short_name=${PACKAGE_SHORT_NAME}" >> $GITHUB_OUTPUT
          echo "current_version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT

      - name: üî¢ Bump version
        if: steps.check-changes.outputs.skip == 'false'
        id: bump-version
        working-directory: ${{ matrix['package-folder'] }}
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")

          # Use synchronized version if sync_versions is enabled
          if [ "${{ github.event.inputs.sync_versions }}" == "true" ]; then
            NEW_VERSION="${{ needs.prepare.outputs.sync-version }}"
            echo "üîÑ Using synchronized version: $NEW_VERSION (was: $CURRENT_VERSION)"
          else
            VERSION_TYPE="${{ github.event.inputs.version || 'patch' }}"
            echo "üìä Current version: $CURRENT_VERSION"
            echo "üîß Version bump type: $VERSION_TYPE"

            # Parse current version
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR=${VERSION_PARTS[0]}
            MINOR=${VERSION_PARTS[1]}
            PATCH=${VERSION_PARTS[2]}

            # Calculate new version based on type
            case "$VERSION_TYPE" in
              "major")
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              "minor")
                MINOR=$((MINOR + 1))
                ;;
              "patch")
                PATCH=$((PATCH + 1))
                ;;
              *)
                echo "‚ùå Unknown version type: $VERSION_TYPE"
                exit 1
                ;;
            esac

            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          fi

          # Skip if version hasn't changed
          if [ "$NEW_VERSION" == "$CURRENT_VERSION" ]; then
            echo "‚è≠Ô∏è Version unchanged ($NEW_VERSION) - skipping package updates"
            echo "version_changed=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Updating version: $CURRENT_VERSION ‚Üí $NEW_VERSION"

            # Update package.json with new version
            node -e "
              const fs = require('fs');
              const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              pkg.version = '$NEW_VERSION';
              fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
            "

            echo "version_changed=true" >> $GITHUB_OUTPUT
          fi

          echo "new_version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "tag_name=v${NEW_VERSION}" >> $GITHUB_OUTPUT

      - name: üìù Generate CHANGELOG
        if: steps.check-changes.outputs.skip == 'false' && steps.bump-version.outputs.version_changed == 'true'
        working-directory: ${{ matrix['package-folder'] }}
        run: |
          PKG_NAME="${{ steps.check-changes.outputs.package_short_name }}"
          NEW_VERSION="${{ steps.bump-version.outputs.new_version }}"
          OLD_VERSION="${{ steps.check-changes.outputs.current_version }}"

          # Get commits since last version tag
          LAST_TAG=$(git describe --tags --abbrev=0 --match="v*" 2>/dev/null || echo "")

          if [ -n "$LAST_TAG" ]; then
            COMMITS=$(git log --oneline --no-merges ${LAST_TAG}..HEAD -- .)
          else
            COMMITS=$(git log --oneline --no-merges -- . | head -10)
          fi

          # Create or update CHANGELOG.md
          if [ ! -f "CHANGELOG.md" ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "All notable changes to this project will be documented in this file." >> CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi

          # Prepare new changelog entry
          TEMP_CHANGELOG=$(mktemp)
          echo "# Changelog" > $TEMP_CHANGELOG
          echo "" >> $TEMP_CHANGELOG

          # Add new version entry
          echo "## [${NEW_VERSION}] - $(date +%Y-%m-%d)" >> $TEMP_CHANGELOG
          echo "" >> $TEMP_CHANGELOG

          # Categorize commits
          FEATURES=""
          FIXES=""
          CHORES=""
          BREAKING=""

          while IFS= read -r commit; do
            if [ -n "$commit" ]; then
              if echo "$commit" | grep -q "^[a-f0-9]* feat[(!:]"; then
                FEATURES="${FEATURES}- ${commit#* }\n"
              elif echo "$commit" | grep -q "^[a-f0-9]* fix[(!:]"; then
                FIXES="${FIXES}- ${commit#* }\n"
              elif echo "$commit" | grep -q "^[a-f0-9]* BREAKING CHANGE"; then
                BREAKING="${BREAKING}- ${commit#* }\n"
              elif echo "$commit" | grep -qE "^[a-f0-9]* (chore|docs|style|refactor|test|build|ci)[(!:]"; then
                CHORES="${CHORES}- ${commit#* }\n"
              else
                CHORES="${CHORES}- ${commit#* }\n"
              fi
            fi
          done <<< "$COMMITS"

          # Add categorized changes
          if [ -n "$BREAKING" ]; then
            echo "### üí• Breaking Changes" >> $TEMP_CHANGELOG
            echo -e "$BREAKING" >> $TEMP_CHANGELOG
          fi

          if [ -n "$FEATURES" ]; then
            echo "### ‚ú® New Features" >> $TEMP_CHANGELOG
            echo -e "$FEATURES" >> $TEMP_CHANGELOG
          fi

          if [ -n "$FIXES" ]; then
            echo "### üêõ Bug Fixes" >> $TEMP_CHANGELOG
            echo -e "$FIXES" >> $TEMP_CHANGELOG
          fi

          if [ -n "$CHORES" ]; then
            echo "### üîß Other Changes" >> $TEMP_CHANGELOG
            echo -e "$CHORES" >> $TEMP_CHANGELOG
          fi

          echo "" >> $TEMP_CHANGELOG

          # Append existing changelog content (skip first few lines)
          if [ -f "CHANGELOG.md" ]; then
            tail -n +4 CHANGELOG.md >> $TEMP_CHANGELOG
          fi

          # Replace changelog
          mv $TEMP_CHANGELOG CHANGELOG.md

          echo "Generated changelog for version $NEW_VERSION"

      - name: üì§ Publish to NPM
        if: steps.check-changes.outputs.skip == 'false' && steps.bump-version.outputs.version_changed == 'true'
        working-directory: ${{ matrix['package-folder'] }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          echo "Publishing package ${{ steps.check-changes.outputs.package_name }} v${{ steps.bump-version.outputs.new_version }}..."

          # Verify package can be built before publishing
          echo "Verifying package integrity..."
          npm pack --dry-run || {
            echo "‚ùå Package verification failed"
            exit 1
          }

          # Check if version already exists on NPM
          EXISTING_VERSION=$(npm view ${{ steps.check-changes.outputs.package_name }}@${{ steps.bump-version.outputs.new_version }} version 2>/dev/null || echo "")
          if [ -n "$EXISTING_VERSION" ]; then
            echo "‚ùå Version ${{ steps.bump-version.outputs.new_version }} already exists on NPM"
            exit 1
          fi

          # Publish package
          echo "üì¶ Publishing to NPM..."
          pnpm publish --access public --no-git-checks || {
            echo "‚ùå Failed to publish package"
            exit 1
          }

          echo "‚úÖ Successfully published ${{ steps.check-changes.outputs.package_name }}@${{ steps.bump-version.outputs.new_version }}"

      - name: üìã Collect published packages info
        if: steps.check-changes.outputs.skip == 'false' && steps.bump-version.outputs.version_changed == 'true'
        id: published-info
        run: |
          PKG_INFO="${{ steps.check-changes.outputs.package_name }}@${{ steps.bump-version.outputs.new_version }}"
          echo "packages=${PKG_INFO}" >> $GITHUB_OUTPUT

  commit-and-release:
    name: üéØ Commit & Create Releases
    needs: [prepare, publish]
    runs-on: ubuntu-latest
    if: ${{ needs.publish.result == 'success' }}
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üéØ Commit all changes and create tags
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Get all packages that were published
          PACKAGES='${{ toJson(fromJson(needs.prepare.outputs.matrix-packages)) }}'
          echo "Processing packages: $PACKAGES"

          # Add root package.json if sync_versions is enabled
          if [ "${{ github.event.inputs.sync_versions }}" == "true" ]; then
            git add "package.json" || true
            echo "Added root package.json"
          fi

          # Add all package.json and CHANGELOG.md changes
          for pkg_folder in $(echo '${{ needs.prepare.outputs.matrix-packages }}' | jq -r '.[]'); do
            if [ -f "${pkg_folder}/package.json" ]; then
              git add "${pkg_folder}/package.json" || true
              git add "${pkg_folder}/CHANGELOG.md" || true
              echo "Added changes for ${pkg_folder}"
            fi
          done

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            if [ "${{ github.event.inputs.sync_versions }}" == "true" ]; then
              git commit -m "chore: bump all packages to synchronized version v${{ needs.prepare.outputs.sync-version }}

              Updated publishable packages:
              $(echo '${{ needs.prepare.outputs.matrix-packages }}' | jq -r '.[]' | sed 's/packages\//- @xsolla-zk\//')"

              # Create unified tag for synchronized release
              git tag "v${{ needs.prepare.outputs.sync-version }}" -m "Synchronized release v${{ needs.prepare.outputs.sync-version }}"
            else
              git commit -m "chore: bump package versions"
            fi
          fi

          # Pull latest changes and push
          git pull --rebase origin main || true
          git push origin HEAD --follow-tags

      - name: üîñ Create GitHub Releases
        run: |
          # Create releases for each published package
          for pkg_folder in $(echo '${{ needs.prepare.outputs.matrix-packages }}' | jq -r '.[]'); do
            PKG_JSON_PATH="${GITHUB_WORKSPACE}/${pkg_folder}/package.json"

            if [ -f "$PKG_JSON_PATH" ]; then
              PKG_NAME=$(node -p "require('$PKG_JSON_PATH').name")
              PKG_VERSION=$(node -p "require('$PKG_JSON_PATH').version")
              PKG_SHORT=$(basename "$pkg_folder")

              echo "Creating release for ${PKG_NAME} v${PKG_VERSION}"

              # Create individual package release
              gh release create "v${PKG_VERSION}" \
                --title "${PKG_SHORT} v${PKG_VERSION}" \
                --notes "## üöÄ ${PKG_NAME} v${PKG_VERSION}

              ### üì¶ Installation
              \`\`\`bash
              npm install ${PKG_NAME}@${PKG_VERSION}
              \`\`\`

              ### üìù Changes
              See [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/${pkg_folder}/CHANGELOG.md) for details." \
                --latest=false || echo "Release may already exist for v${PKG_VERSION}"
            else
              echo "Warning: package.json not found at $PKG_JSON_PATH"
            fi
          done
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  notify:
    name: üì¢ Notify Results
    needs: [prepare, publish, commit-and-release]
    runs-on: ubuntu-latest
    if: always() && fromJson(needs.prepare.outputs['matrix-packages']) && fromJson(needs.prepare.outputs['matrix-packages'])[0] != null
    steps:
      - name: üìä Check overall status
        run: |
          if [ "${{ needs.publish.result }}" == "success" ] && [ "${{ needs.commit-and-release.result }}" == "success" ]; then
            echo "‚úÖ All packages published and committed successfully!"
            echo "OVERALL_STATUS=success" >> $GITHUB_ENV
          elif [ "${{ needs.publish.result }}" == "failure" ]; then
            echo "‚ùå Packages failed to publish. No commits were made to main."
            echo "OVERALL_STATUS=failure" >> $GITHUB_ENV
            exit 1
          elif [ "${{ needs.commit-and-release.result }}" == "failure" ]; then
            echo "‚ö†Ô∏è Packages published but commit/release failed."
            echo "OVERALL_STATUS=partial" >> $GITHUB_ENV
          elif [ "${{ needs.publish.result }}" == "cancelled" ]; then
            echo "‚èπÔ∏è Publishing was cancelled."
            echo "OVERALL_STATUS=cancelled" >> $GITHUB_ENV
            exit 1
          else
            echo "‚ö†Ô∏è Publishing completed with unknown status"
            echo "OVERALL_STATUS=unknown" >> $GITHUB_ENV
          fi

      - name: üéâ Success notification
        if: env.OVERALL_STATUS == 'success'
        run: |
          echo "üöÄ Deployment completed successfully!"
          echo "All packages have been published to NPM and changes committed to main."

      - name: üí• Failure notification
        if: env.OVERALL_STATUS == 'failure'
        run: |
          echo "üí• Deployment failed!"
          echo "Packages failed to publish. No changes were made to the repository."
          echo "Please check the logs above for details."

      - name: ‚ö†Ô∏è Partial success notification
        if: env.OVERALL_STATUS == 'partial'
        run: |
          echo "‚ö†Ô∏è Partial success!"
          echo "Packages were published to NPM but commit/release creation failed."
          echo "Manual intervention may be required."

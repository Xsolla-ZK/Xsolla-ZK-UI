name: Build & Publish Packages

on:
  push:
    branches:
      - main
    paths:
      - 'packages/**'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version type (major, minor, patch)'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      packages:
        description: 'Comma-separated list of packages to publish (without `packages/` prefix). If left empty ‚Äî will be found all changed packages.'
        required: false
        type: string
      sync_versions:
        description: 'Synchronize all packages to the same version'
        required: false
        default: false
        type: boolean

env:
  REGISTRY_URL: 'https://registry.npmjs.org'
  # If need to use GitHub Packages instead of npmjs.org, uncomment the line below
  # REGISTRY_URL: 'https://npm.pkg.github.com'

jobs:
  prepare:
    name: ‚è≥ Prepare list of packages
    runs-on: ubuntu-latest
    outputs:
      matrix-packages: ${{ steps.set-matrix.outputs['matrix-packages'] }}
      sync-version: ${{ steps.calculate-sync-version.outputs['sync-version'] }}
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîç Define packages to publish
        id: set-matrix
        run: |
          if [ "${{ github.event.inputs.sync_versions }}" == "true" ]; then
            echo "üîÑ Sync versions enabled - including all packages"
            # Include all packages when sync_versions is enabled
            ALL_PKGS=$(find packages -maxdepth 1 -type d | grep -v '^packages$' | sort)
            echo "Found packages:"
            for pkg in $ALL_PKGS; do
              echo "  - $pkg"
            done
            MATRIX_JSON="["
            for pkg in $ALL_PKGS; do
              MATRIX_JSON+="\"${pkg}\","
            done
            MATRIX_JSON="${MATRIX_JSON%,}]"
          elif [ -n "${{ github.event.inputs.packages }}" ]; then
            echo "üì¶ Manual packages specified: ${{ github.event.inputs.packages }}"
            IFS=',' read -ra ARR <<< "${{ github.event.inputs.packages }}"
            MATRIX_JSON="["
            for pkg in "${ARR[@]}"; do
              trim="$(echo "$pkg" | xargs)"
              echo "  - packages/${trim}"
              MATRIX_JSON+="\"packages/${trim}\","
            done
            MATRIX_JSON="${MATRIX_JSON%,}]"
          else
            echo "üîç Checking for changed packages since ${{ github.event.before }}"
            CHANGED_PKGS=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} \
                        | grep '^packages/' | cut -d'/' -f2 | sort -u)
            if [ -z "$CHANGED_PKGS" ]; then
              echo "No changes in packages/, nothing to publish."
              MATRIX_JSON="[]"
            else
              echo "Changed packages:"
              MATRIX_JSON="["
              for pkg in $CHANGED_PKGS; do
                echo "  - packages/${pkg}"
                MATRIX_JSON+="\"packages/${pkg}\","
              done
              MATRIX_JSON="${MATRIX_JSON%,}]"
            fi
          fi

          echo ">>> Final matrix-packages: $MATRIX_JSON"
          echo "matrix-packages=$(jq -cr '@json' <<< "$MATRIX_JSON")" >> $GITHUB_OUTPUT

      - name: üî¢ Calculate synchronized version
        id: calculate-sync-version
        if: github.event.inputs.sync_versions == 'true'
        run: |
          echo "üîÑ Calculating synchronized version for all packages..."

          # Find the highest version among all packages
          HIGHEST_VERSION="0.0.0"

          for pkg_dir in packages/*/; do
            if [ -f "${pkg_dir}package.json" ]; then
              PKG_VERSION=$(node -p "require('${pkg_dir}package.json').version" 2>/dev/null || echo "0.0.0")
              echo "Package $(basename $pkg_dir): $PKG_VERSION"

              # Compare versions (simple lexicographic comparison for semver)
              if [ "$(printf '%s\n' "$PKG_VERSION" "$HIGHEST_VERSION" | sort -V | tail -n1)" = "$PKG_VERSION" ]; then
                HIGHEST_VERSION="$PKG_VERSION"
              fi
            fi
          done

          echo "Highest current version: $HIGHEST_VERSION"

          # Calculate new version based on bump type
          VERSION_TYPE="${{ github.event.inputs.version || 'patch' }}"
          IFS='.' read -ra VERSION_PARTS <<< "$HIGHEST_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}

          case "$VERSION_TYPE" in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac

          SYNC_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "New synchronized version: $SYNC_VERSION"
          echo "sync-version=$SYNC_VERSION" >> $GITHUB_OUTPUT

  debug-matrix:
    name: üêõ Debug matrix-packages
    needs: prepare
    runs-on: ubuntu-latest
    steps:
      - name: Show raw string and length
        run: |
          echo "RAW from prepare: ${{ needs.prepare.outputs['matrix-packages'] }}"
          echo "Not Empty: ${{ fromJson(needs.prepare.outputs['matrix-packages'])[0] != null }}"
          echo "First Element: ${{ fromJson(needs.prepare.outputs['matrix-packages'])[0] }}"

  build:
    name: üî® Build all packages
    runs-on: ubuntu-latest
    needs: prepare
    if: ${{ fromJson(needs.prepare.outputs['matrix-packages']) && fromJson(needs.prepare.outputs['matrix-packages'])[0] != null }}
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ‚öôÔ∏è Setup Node.js & PNPM
        uses: pnpm/action-setup@v4
        with:
          version: '10.3.0'
      - name: üîß Setup Node.js (for npmrc)
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          registry-url: ${{ env.REGISTRY_URL }}

      - name: üì¶ Install dependencies
        run: pnpm install --frozen-lockfile

      - name: üèó Build all packages
        run: pnpm build

      - name: üìù Lint packages
        run: pnpm lint:react

  publish:
    name: üöÄ Publish packages
    needs: [prepare, build]
    runs-on: ubuntu-latest
    if: ${{ fromJson(needs.prepare.outputs['matrix-packages']) && fromJson(needs.prepare.outputs['matrix-packages'])[0] != null }}
    permissions:
      contents: write
      packages: write
    strategy:
      fail-fast: true
      matrix:
        package-folder: ${{ fromJson(needs.prepare.outputs['matrix-packages']) }}
    outputs:
      published-packages: ${{ steps.published-info.outputs.packages }}

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ‚öôÔ∏è Setup Node.js & PNPM
        uses: pnpm/action-setup@v4
        with:
          version: '10.3.0'
      - name: üîß Setup Node.js (for npmrc)
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          registry-url: ${{ env.REGISTRY_URL }}
          always-auth: true

      - name: üõ°Ô∏è Setup npm Auth
        run: |
          echo "//$(echo ${{ env.REGISTRY_URL }} | sed 's#https://##')/:_authToken=${{ secrets.NPM_TOKEN }}" > ~/.npmrc
          echo "registry=${{ env.REGISTRY_URL }}" >> ~/.npmrc

      - name: üì¶ Install dependencies (only root)
        run: pnpm install --frozen-lockfile

      - name: üßê Check changes in package
        id: check-changes
        working-directory: ${{ matrix['package-folder'] }}
        run: |
          # Take name and version from specified package
          PACKAGE_NAME=$(node -p "require('${PWD}/package.json').name")
          CURRENT_VERSION=$(node -p "require('${PWD}/package.json').version")
          PACKAGE_SHORT_NAME=${PWD##*/}

          # When sync_versions is enabled, always process all packages
          if [ "${{ github.event.inputs.sync_versions }}" == "true" ]; then
            echo "üîÑ Sync versions enabled - processing package: $PACKAGE_NAME"
            echo "skip=false" >> $GITHUB_OUTPUT
          # For workflow_dispatch without sync_versions, process specified packages
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "üì¶ Manual trigger - processing package: $PACKAGE_NAME"
            echo "skip=false" >> $GITHUB_OUTPUT
          # For push events, check if there are changes in this folder
          elif git diff --quiet HEAD~1 HEAD -- . 2>/dev/null; then
            echo "‚è≠Ô∏è No changes in package: $PACKAGE_NAME - skipping"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "üìù Changes detected in package: $PACKAGE_NAME - processing"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

          echo "package_name=${PACKAGE_NAME}" >> $GITHUB_OUTPUT
          echo "package_short_name=${PACKAGE_SHORT_NAME}" >> $GITHUB_OUTPUT
          echo "current_version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT

      - name: üî¢ Bump version
        if: steps.check-changes.outputs.skip == 'false'
        id: bump-version
        working-directory: ${{ matrix['package-folder'] }}
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")

          # Use synchronized version if sync_versions is enabled
          if [ "${{ github.event.inputs.sync_versions }}" == "true" ]; then
            NEW_VERSION="${{ needs.prepare.outputs.sync-version }}"
            echo "üîÑ Using synchronized version: $NEW_VERSION (was: $CURRENT_VERSION)"
          else
            VERSION_TYPE="${{ github.event.inputs.version || 'patch' }}"
            echo "üìä Current version: $CURRENT_VERSION"
            echo "üîß Version bump type: $VERSION_TYPE"

            # Parse current version
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR=${VERSION_PARTS[0]}
            MINOR=${VERSION_PARTS[1]}
            PATCH=${VERSION_PARTS[2]}

            # Calculate new version based on type
            case "$VERSION_TYPE" in
              "major")
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              "minor")
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              "patch")
                PATCH=$((PATCH + 1))
                ;;
              *)
                echo "‚ùå Unknown version type: $VERSION_TYPE"
                exit 1
                ;;
            esac

            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          fi

          # Skip if version hasn't changed
          if [ "$NEW_VERSION" == "$CURRENT_VERSION" ]; then
            echo "‚è≠Ô∏è Version unchanged ($NEW_VERSION) - skipping package updates"
            echo "version_changed=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Updating version: $CURRENT_VERSION ‚Üí $NEW_VERSION"

            # Update package.json with new version
            node -e "
              const fs = require('fs');
              const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              pkg.version = '$NEW_VERSION';
              fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
            "

            echo "version_changed=true" >> $GITHUB_OUTPUT
          fi

          echo "new_version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "tag_name=v${NEW_VERSION}" >> $GITHUB_OUTPUT

      - name: üìù Generate CHANGELOG
        if: steps.check-changes.outputs.skip == 'false' && steps.bump-version.outputs.version_changed == 'true'
        working-directory: ${{ matrix['package-folder'] }}
        run: |
          PKG_NAME="${{ steps.check-changes.outputs.package_short_name }}"
          NEW_VERSION="${{ steps.bump-version.outputs.new_version }}"
          OLD_VERSION="${{ steps.check-changes.outputs.current_version }}"

          # Get commits since last version tag
          LAST_TAG=$(git describe --tags --abbrev=0 --match="v*" 2>/dev/null || echo "")

          if [ -n "$LAST_TAG" ]; then
            COMMITS=$(git log --oneline --no-merges ${LAST_TAG}..HEAD -- .)
          else
            COMMITS=$(git log --oneline --no-merges -- . | head -10)
          fi

          # Create or update CHANGELOG.md
          if [ ! -f "CHANGELOG.md" ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "All notable changes to this project will be documented in this file." >> CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi

          # Prepare new changelog entry
          TEMP_CHANGELOG=$(mktemp)
          echo "# Changelog" > $TEMP_CHANGELOG
          echo "" >> $TEMP_CHANGELOG

          # Add new version entry
          echo "## [${NEW_VERSION}] - $(date +%Y-%m-%d)" >> $TEMP_CHANGELOG
          echo "" >> $TEMP_CHANGELOG

          # Categorize commits
          FEATURES=""
          FIXES=""
          CHORES=""
          BREAKING=""

          while IFS= read -r commit; do
            if [ -n "$commit" ]; then
              if echo "$commit" | grep -q "^[a-f0-9]* feat[(!:]"; then
                FEATURES="${FEATURES}- ${commit#* }\n"
              elif echo "$commit" | grep -q "^[a-f0-9]* fix[(!:]"; then
                FIXES="${FIXES}- ${commit#* }\n"
              elif echo "$commit" | grep -q "^[a-f0-9]* BREAKING CHANGE"; then
                BREAKING="${BREAKING}- ${commit#* }\n"
              elif echo "$commit" | grep -qE "^[a-f0-9]* (chore|docs|style|refactor|test|build|ci)[(!:]"; then
                CHORES="${CHORES}- ${commit#* }\n"
              else
                CHORES="${CHORES}- ${commit#* }\n"
              fi
            fi
          done <<< "$COMMITS"

          # Add categorized changes
          if [ -n "$BREAKING" ]; then
            echo "### üí• Breaking Changes" >> $TEMP_CHANGELOG
            echo -e "$BREAKING" >> $TEMP_CHANGELOG
          fi

          if [ -n "$FEATURES" ]; then
            echo "### ‚ú® New Features" >> $TEMP_CHANGELOG
            echo -e "$FEATURES" >> $TEMP_CHANGELOG
          fi

          if [ -n "$FIXES" ]; then
            echo "### üêõ Bug Fixes" >> $TEMP_CHANGELOG
            echo -e "$FIXES" >> $TEMP_CHANGELOG
          fi

          if [ -n "$CHORES" ]; then
            echo "### üîß Other Changes" >> $TEMP_CHANGELOG
            echo -e "$CHORES" >> $TEMP_CHANGELOG
          fi

          echo "" >> $TEMP_CHANGELOG

          # Append existing changelog content (skip first few lines)
          if [ -f "CHANGELOG.md" ]; then
            tail -n +4 CHANGELOG.md >> $TEMP_CHANGELOG
          fi

          # Replace changelog
          mv $TEMP_CHANGELOG CHANGELOG.md

          echo "Generated changelog for version $NEW_VERSION"

      - name: üéØ Commit version & tag
        if: steps.check-changes.outputs.skip == 'false' && steps.bump-version.outputs.version_changed == 'true'
        run: |
          PKG_FOLDER="${{ matrix['package-folder'] }}"
          PKG_SHORT="${{ steps.check-changes.outputs.package_short_name }}"
          NEW_VERSION="${{ steps.bump-version.outputs.new_version }}"
          TAG_NAME="${{ steps.bump-version.outputs.tag_name }}"

          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          git add "${PKG_FOLDER}/package.json"
          git add "${PKG_FOLDER}/CHANGELOG.md" || true

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore(${PKG_SHORT}): bump version to v${NEW_VERSION}"
          fi

          # Create tag in format vX.X.X
          git tag "$TAG_NAME" -m "Release ${PKG_SHORT} v${NEW_VERSION}" || echo "Tag already exists"

          # Pull latest changes to avoid conflicts
          echo "Pulling latest changes from remote..."
          git pull --rebase origin main || {
            echo "Pull failed, trying to resolve conflicts..."
            # If there are conflicts, prefer our changes for package.json and CHANGELOG.md
            git checkout --ours "${PKG_FOLDER}/package.json" || true
            git checkout --ours "${PKG_FOLDER}/CHANGELOG.md" || true
            git add "${PKG_FOLDER}/package.json" "${PKG_FOLDER}/CHANGELOG.md" || true
            git rebase --continue || {
              echo "Rebase failed, aborting rebase and trying force push..."
              git rebase --abort || true
            }
          }

          # Push commit and tag with retry logic
          for i in {1..3}; do
            echo "Push attempt $i..."
            if git push origin HEAD --follow-tags; then
              echo "Push successful"
              break
            else
              if [ $i -eq 3 ]; then
                echo "All push attempts failed"
                exit 1
              fi
              echo "Push failed, waiting 10 seconds before retry..."
              sleep 10
              git pull --rebase origin main || true
            fi
          done

      - name: üì§ Publish to NPM
        if: steps.check-changes.outputs.skip == 'false' && steps.bump-version.outputs.version_changed == 'true'
        working-directory: ${{ matrix['package-folder'] }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          echo "Publishing package ${{ steps.check-changes.outputs.package_name }} v${{ steps.bump-version.outputs.new_version }}..."

          # Verify package can be built before publishing
          echo "Verifying package integrity..."
          npm pack --dry-run || {
            echo "‚ùå Package verification failed"
            exit 1
          }

          # Check if version already exists on NPM
          EXISTING_VERSION=$(npm view ${{ steps.check-changes.outputs.package_name }}@${{ steps.bump-version.outputs.new_version }} version 2>/dev/null || echo "")
          if [ -n "$EXISTING_VERSION" ]; then
            echo "‚ùå Version ${{ steps.bump-version.outputs.new_version }} already exists on NPM"
            exit 1
          fi

          # Publish package
          echo "üì¶ Publishing to NPM..."
          pnpm publish --access public --no-git-checks || {
            echo "‚ùå Failed to publish package"
            exit 1
          }

          echo "‚úÖ Successfully published ${{ steps.check-changes.outputs.package_name }}@${{ steps.bump-version.outputs.new_version }}"

      - name: üîñ Create GitHub Release
        if: steps.check-changes.outputs.skip == 'false' && steps.bump-version.outputs.version_changed == 'true'
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ steps.bump-version.outputs.tag_name }}
          name: "${{ steps.check-changes.outputs.package_short_name }} v${{ steps.bump-version.outputs.new_version }}"
          body: |
            ## üöÄ ${{ steps.check-changes.outputs.package_name }} v${{ steps.bump-version.outputs.new_version }}

            ### üì¶ Installation
            ```bash
            npm install ${{ steps.check-changes.outputs.package_name }}@${{ steps.bump-version.outputs.new_version }}
            # or
            pnpm add ${{ steps.check-changes.outputs.package_name }}@${{ steps.bump-version.outputs.new_version }}
            # or
            yarn add ${{ steps.check-changes.outputs.package_name }}@${{ steps.bump-version.outputs.new_version }}
            ```

            ### üìù Changes
            Updated version: **${{ github.event.inputs.version || 'patch' }}**

            See the [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/${{ matrix['package-folder'] }}/CHANGELOG.md) for details.

            ### üîó Links
            - [NPM Package](https://www.npmjs.com/package/${{ steps.check-changes.outputs.package_name }})
            - [Documentation](https://github.com/${{ github.repository }}/tree/main/${{ matrix['package-folder'] }})
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: üìã Collect published packages info
        if: steps.check-changes.outputs.skip == 'false' && steps.bump-version.outputs.version_changed == 'true'
        id: published-info
        run: |
          PKG_INFO="${{ steps.check-changes.outputs.package_name }}@${{ steps.bump-version.outputs.new_version }}"
          echo "packages=${PKG_INFO}" >> $GITHUB_OUTPUT

  notify:
    name: üì¢ Notify Results
    needs: [prepare, publish]
    runs-on: ubuntu-latest
    if: always() && fromJson(needs.prepare.outputs['matrix-packages']) && fromJson(needs.prepare.outputs['matrix-packages'])[0] != null
    steps:
      - name: üìä Check overall status
        run: |
          if [ "${{ needs.publish.result }}" == "success" ]; then
            echo "‚úÖ All packages published successfully!"
            echo "OVERALL_STATUS=success" >> $GITHUB_ENV
          elif [ "${{ needs.publish.result }}" == "failure" ]; then
            echo "‚ùå Some packages failed to publish. All publishing stopped."
            echo "OVERALL_STATUS=failure" >> $GITHUB_ENV
            exit 1
          elif [ "${{ needs.publish.result }}" == "cancelled" ]; then
            echo "‚èπÔ∏è Publishing was cancelled."
            echo "OVERALL_STATUS=cancelled" >> $GITHUB_ENV
            exit 1
          else
            echo "‚ö†Ô∏è Publishing completed with unknown status: ${{ needs.publish.result }}"
            echo "OVERALL_STATUS=unknown" >> $GITHUB_ENV
          fi

      - name: üéâ Success notification
        if: env.OVERALL_STATUS == 'success'
        run: |
          echo "üöÄ Deployment completed successfully!"
          echo "All packages have been published to NPM and GitHub releases created."

      - name: üí• Failure notification
        if: env.OVERALL_STATUS == 'failure'
        run: |
          echo "üí• Deployment failed!"
          echo "One or more packages failed to publish. No packages were published to maintain consistency."
          echo "Please check the logs above for details."
